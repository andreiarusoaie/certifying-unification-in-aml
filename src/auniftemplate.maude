load aunif-proof-generator.maude

mod PRETTY is
    pr PROOF-GENERATION .

    DECLARATIONS

    op _-->_ : TermPattern TermPattern -> TermPattern .
    op _<-->_ : TermPattern TermPattern -> TermPattern .
    op _===_ : TermPattern TermPattern -> TermPattern .
    op _`[_`] : TermPattern TermPattern -> TermPattern .
    op ∃_._ : Vars TermPattern -> TermPattern .
    op v : NzNat -> EVar .

    vars N : NzNat .
    vars Tp Tp' F Tp1 Tp2 : TermPattern .
    vars Pr : ProofRule .
    vars P1 P2 : Proof .
    vars X : EVar .
    vars Xs : Vars .

    op pretty : Proof -> Proof [memo format(nm d)] .
    ops tt ff : -> TermPattern . *** true and false
    eq pretty(.Proof) = .Proof .
    ceq pretty((P1 P2)) = pretty(P1) pretty(P2) if (P1 =/= .Proof) /\ (P2 =/= .Proof) .
    eq pretty((N) Tp Pr ;) = (N) prettyTermPattern(Tp) Pr ; .

    op prettyTermPattern : TermPattern -> TermPattern [memo] .
    --- eq prettyTermPattern(\imp(\bot, \bot)) = tt .  
    eq prettyTermPattern(\bot) = ff .
    eq prettyTermPattern(\imp(Tp1, Tp2)) = prettyTermPattern(Tp1) --> prettyTermPattern(Tp2) .
    eq prettyTermPattern(\eqv(Tp1, Tp2)) = prettyTermPattern(Tp1) <--> prettyTermPattern(Tp2) .
    eq prettyTermPattern(\eq(Tp1, Tp2)) = prettyTermPattern(Tp1) === prettyTermPattern(Tp2) .
    eq prettyTermPattern(Tp1 and Tp2) = prettyTermPattern(Tp1) and prettyTermPattern(Tp2) .
    eq prettyTermPattern(Tp1 or Tp2) = prettyTermPattern(Tp1) or prettyTermPattern(Tp2) .
    eq prettyTermPattern(\exists(Xs, Tp)) = ∃ prettyVars(Xs) . prettyTermPattern(Tp) .

    op prettyVars : Vars -> Vars [memo] .
    eq prettyVars(.Vars) = .Vars .
    eq prettyVars( (X ; Xs) ) = prettyTermPattern(X) ; prettyVars(Xs) . 
    
    PRETTYPRINT
    eq prettyTermPattern(\evar(N)) = v(N) [owise] .

endm
rew in PRETTY : pretty(gen-proof(
    TERM1,
    TERM2
    )) .
rew in PRETTY : check(gen-proof(
    TERM1,
    TERM2
    )) .
q
