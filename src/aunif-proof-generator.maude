load checker

mod SETUP is
    pr PROOF .
    pr INT .

    sorts Pair Pairs .
    subsorts Pair < Pairs .
    op .Pairs : -> Pairs .
    op __ : Pairs Pairs -> Pairs [assoc prec 120 id: .Pairs] .
    op _⊔_ : TermPattern TermPattern -> Pair .

    var Pr : Pair .
    op size : Pairs -> Nat .
    eq size(.Pairs) = 0 .
    eq size(Pr) = 1 .
    ceq size((P P')) = size(P) + size(P') if P =/= .Pairs /\ P' =/= .Pairs .

    sort MaybePairs .
    op nothing : -> MaybePairs .
    op just_ : Pairs -> MaybePairs .
    op _;_ : MaybePairs MaybePairs -> MaybePairs .
    vars M : MaybePairs .
    vars P P' : Pairs .
    eq nothing ; M = nothing .
    eq M ; nothing = nothing .
    eq just P ; just P' = just (P P') .

    vars N N' : Nat .
    vars T T' F F' : TermPattern .
    op dec-reverse : TermPattern TermPattern -> MaybePairs .
    ceq dec-reverse(\app(\symb(N), T), \app(\symb(N'), T')) = nothing if N =/= N' .
    eq dec-reverse(\app(\symb(N), T), \app(\symb(N), T')) = just (T ⊔ T') .
    eq dec-reverse(\app(F, T), \app(F', T')) = dec-reverse(F, F') ; just (T ⊔ T') .
    eq dec-reverse(T, T') = nothing [owise] .

    sorts SubstPair SubstList .
    op subst-pair : EVar TermPattern -> SubstPair .
    op subst-cons : SubstPair SubstList -> SubstList .
    op subst-nil : -> SubstList .

    op collapse : SubstList -> SubstPair .
    vars X Y : EVar .
    vars Phi Phi' T1 T2 : TermPattern .
    var PR : SubstPair .
    var PL : SubstList .
    eq collapse(subst-cons(PR, subst-nil)) = PR .

    eq collapse(subst-cons(subst-pair(Y, Phi), subst-cons(subst-pair(X, Phi'), PL))) =
       collapse(subst-cons(subst-pair(X, (Phi' [ Phi / Y ])), PL)) .

    sorts Equation Equations .
    subsort Equation < Equations .
    op .Equations : -> Equations .
    op _={_}_ : TermPattern EVar TermPattern -> Equation .
    op __ : Equations Equations -> Equations [assoc comm prec 120 id: .Equations] .

    op fresh : EVar -> EVar .
    eq fresh(\evar(N)) = \evar(N + 1) .

    op generate-vars : EVar Int -> Vars .
    eq generate-vars(X, 0) = .Vars .
    ceq generate-vars(X, N) = Y ; generate-vars(Y, N - 1) if Y := fresh(X) .

    vars Eq : Equation .
    vars Eqs1 Eqs2 : Equations .
    op solved : Equations -> Bool .
    eq solved(.Equations) = true .
    ceq solved(T1 ={ X } T2) = true if dec-reverse(T1, T2) == nothing .
    ceq solved((Eqs1 Eqs2)) = solved(Eqs1) and solved(Eqs2) if (Eqs1 =/= .Equations and Eqs2 =/= .Equations) .
    eq solved(Eqs1) = false [owise] .

endm

mod ANTI-UNIFICATION is
    pr SETUP .

    sort AUnifProblem .
    *** op anti-unif : AUnifProblem -> AUnifProblem .
    op <_|_|_|_> : SubstList Equations Proof Int -> AUnifProblem .

    vars Eqs Eqs' Eqs1 Eqs2 : Equations .
    vars N : Nat .
    vars Prf Prf' : Proof .
    vars SL SL' : SubstList .
    vars Phi Phi' T1 T2 T T' Trm EQL EQR : TermPattern .
    vars X Y : EVar .
    vars Vs : Vars .
    vars Ps : Pairs .
    vars K : Int .


    crl [decompose]:  < SL | (T1 ={ X } T2) Eqs | Prf | K > =>
                     < SL' | Eqs' Eqs | Prf
        (K) \eq(\exists(X, T and ( (Phi and (\eq(X, T1))) or (Phi' and (\eq(X, T2))) )),
          arrange(X, \exists(X, T and ( (Phi and (\eq(X, T1))) or (Phi' and (\eq(X, T2))) )))) [exists-equiv];
        (K + 1) \eq(\exists(X, T and ( (Phi and (\eq(X, T1))) or (Phi' and (\eq(X, T2))) )),
          prec(Vs, \exists(X, T and \eq(X, Trm) and
              ((Phi and EQL) or (Phi' and EQR)))) ) [antiunification-dec] ;
        (K + 2) \eq(
          prec(Vs, \exists(X, T and \eq(X, Trm) and ((Phi and EQL) or (Phi' and EQR)))),
          prec(Vs, (T  and  ((Phi and EQL) or (Phi' and EQR)))[ Trm / X ] )) [exists-elim];
        | K + 3 >
      if just Ps := dec-reverse(T1, T2) /\
          Vs := generate-vars(X, size(Ps)) /\
          Phi := phi-left(Eqs) /\
          Phi' := phi-right(Eqs) /\
          EQL := equalities-left(Vs, Ps) /\
          EQR := equalities-right(Vs, Ps) /\
          Eqs' := eqs-build(Vs, Ps) /\
          Trm := generate-term(Vs,get-top-symbol(T1)) /\
          subst-pair(Y, T) := collapse(SL) /\
          SL' := subst-cons(subst-pair(X, Trm), SL) .

    op generate-term : Vars TermPattern -> TermPattern .
    eq generate-term(.Vars, T) = T .
    eq generate-term((X ; Vs), T) = generate-term(Vs, \app(T, X)) .

    op get-proof : AUnifProblem -> Proof .
    eq get-proof(< SL | Eqs | Prf | K >) = Prf .

    op get-eqs : AUnifProblem -> Equations .
    eq get-eqs(< SL | Eqs | Prf | K >) = Eqs .

    op phi-left : Equations -> TermPattern .
    eq phi-left(.Equations) =  \imp(\bot, \bot) .
    eq phi-left(T1 ={ X } T2) = \eq(X, T1) .
    ceq phi-left((Eqs1 Eqs2)) = phi-left(Eqs1) and phi-left(Eqs2)
      if Eqs1 =/= .Equations /\ Eqs2 =/= .Equations .

    op phi-right : Equations -> TermPattern .
    eq phi-right(.Equations) =  \imp(\bot, \bot) .
    eq phi-right(T1 ={ X } T2) = \eq(X, T2) .
    ceq phi-right((Eqs1 Eqs2)) = phi-right(Eqs1) and phi-right(Eqs2)
      if Eqs1 =/= .Equations /\ Eqs2 =/= .Equations .

    op equalities-left : Vars Pairs -> TermPattern .
    eq equalities-left(.Vars, .Pairs) = \imp(\bot, \bot) .
    eq equalities-left((X ; Vs), (( T1 ⊔ T2) Ps)) = \eq(X, T1) and equalities-left(Vs, Ps) .

    op equalities-right : Vars Pairs -> TermPattern .
    eq equalities-right(.Vars, .Pairs) = \imp(\bot, \bot) .
    eq equalities-right((X ; Vs), (( T1 ⊔ T2) Ps)) = \eq(X, T2) and equalities-right(Vs, Ps) .

    op eqs-build : Vars Pairs -> Equations .
    eq eqs-build(.Vars, .Pairs) = .Equations .
    eq eqs-build((X ; Vs), (( T1 ⊔ T2) Ps)) = (T1 ={ X } T2) eqs-build(Vs, Ps) .

    op prec : Vars TermPattern -> TermPattern .
    eq prec(.Vars, T) = T .
    eq prec((X ; Vs), T) = prec(Vs, \exists(X, T)) .

    op arrange : EVar TermPattern -> TermPattern .
    ceq arrange(X, T) = \exists(X, prec(Vs, T')) if {Vs, T'} := find(X, T) .
    sort FindResult .
    op {_,_} : Vars TermPattern -> FindResult .
    op find : EVar TermPattern -> FindResult .
    eq find(X, \exists(X, T)) = {.Vars, T} .
    ceq find(X, \exists(Y, T)) = {(Y ; Vs), T'} if X =/= Y /\ {Vs, T'} := find(X, T) .

    eq \imp(\bot, \bot) and T = T .
endm



mod PROOF-GENERATION is
    inc ANTI-UNIFICATION .
    pr CHECKER .
    pr INT .


    op gen-proof1 : TermPattern TermPattern -> Proof .
    op gen-proof2 : TermPattern TermPattern -> Proof .

    vars T1 T2 : TermPattern .
    vars SL : SubstList .
    vars Eqs : Equations .
    vars Prf : Proof .
    var A : AUnifProblem .

    --- Stage 1
    crl gen-proof1(T1, T2) => get-proof(A)
      if < subst-cons(subst-pair(\evar(100), \evar(100)), subst-nil) | (T1 ={ \evar(100) } T2) | .Proof | 1 > => A /\ solved(get-eqs(A)) .

endm


mod PRETTY is
    pr PROOF-GENERATION .

    op f : TermPattern TermPattern -> TermPattern .
    op g : TermPattern TermPattern -> TermPattern .
    op u :  -> TermPattern .
    op t :  -> TermPattern .
    op x : -> EVar .
    op z : -> EVar .
    op v : NzNat -> EVar .

    op _-->_ : TermPattern TermPattern -> TermPattern .
    op _===_ : TermPattern TermPattern -> TermPattern .
    op _`[_`] : TermPattern TermPattern -> TermPattern .
    op ∃_._ : EVar TermPattern -> TermPattern .

    vars N : NzNat .
    vars Tp Tp' F Tp1 Tp2 : TermPattern .
    vars Pr : ProofRule .
    vars P1 P2 : Proof .
    vars X : EVar .

    op pretty : Proof -> Proof [format(nm d)] .
    ops tt ff : -> TermPattern . *** true and false
    eq pretty(.Proof) = .Proof .
    ceq pretty((P1 P2)) = pretty(P1) pretty(P2) if (P1 =/= .Proof) /\ (P2 =/= .Proof) .
    eq pretty((N) Tp Pr ;) = (N) prettyTermPattern(Tp) Pr ; .

    op prettyTermPattern : TermPattern -> TermPattern .
    --- eq prettyTermPattern(\imp(\bot, \bot)) = tt .  
    eq prettyTermPattern(\bot) = ff .
    eq prettyTermPattern(\imp(Tp1, Tp2)) = prettyTermPattern(Tp1) --> prettyTermPattern(Tp2) .
    eq prettyTermPattern(\eq(Tp1, Tp2)) = prettyTermPattern(Tp1) === prettyTermPattern(Tp2) .
    eq prettyTermPattern(Tp1 and Tp2) = prettyTermPattern(Tp1) and prettyTermPattern(Tp2) .
    eq prettyTermPattern(Tp1 or Tp2) = prettyTermPattern(Tp1) or prettyTermPattern(Tp2) .
    eq prettyTermPattern(\exists(X, Tp)) = ∃ prettyTermPattern(X) . prettyTermPattern(Tp) .

    vars T1 T2 : TermPattern .
    eq prettyTermPattern(\app(\app(\symb(1), T1), T2)) = f(prettyTermPattern(T1),prettyTermPattern(T2)) .
    eq prettyTermPattern(\app(\app(\symb(3), T1), T2)) = g(prettyTermPattern(T1),prettyTermPattern(T2)) .
    eq prettyTermPattern(\symb(5)) = u .
    eq prettyTermPattern(\symb(6)) = t .
    eq prettyTermPattern(\evar(2)) = x .
    eq prettyTermPattern(\evar(4)) = z .
    eq prettyTermPattern(\evar(N)) = v(N) [owise] .

endm
rew in PRETTY : pretty(gen-proof1(
    \app(\app(\symb(1), \evar(2)), \app(\app(\symb(3), \evar(4)), \evar(2))),
    \app(\app(\symb(1), \evar(2)), \app(\app(\symb(3), \symb(5)), \symb(6)))
    )) .
rew in PRETTY : check(gen-proof1(
    \app(\app(\symb(1), \evar(2)), \app(\app(\symb(3), \evar(4)), \evar(2))),
    \app(\app(\symb(1), \evar(2)), \app(\app(\symb(3), \symb(5)), \symb(6)))
)) .

rew in PRETTY : gen-proof1(
    \app(\app(\symb(1), \evar(2)), \app(\app(\symb(3), \evar(4)), \evar(2))),
    \app(\app(\symb(1), \evar(2)), \app(\app(\symb(3), \symb(5)), \symb(6)))
    ) .

rew in PRETTY :
< subst-cons(subst-pair(\evar(100), \evar(100)), subst-nil) |
(\app(\app(\symb(1), \evar(2)), \app(\app(\symb(3), \evar(4)), \evar(2)))  ={ \evar(100) }
\app(\app(\symb(1), \evar(2)), \app(\app(\symb(3), \symb(5)), \symb(6))))
| .Proof | 1 > .


debug rew in PRETTY :
    < subst-cons(subst-pair(\evar(100), \app(\app(\symb(1), \evar(101)), \evar(102))), subst-cons(subst-pair(\evar(100),
    \evar(100)), subst-nil)) | \evar(2) ={\evar(101)}\evar(2) \app(\app(\symb(3), \evar(4)), \evar(2)) ={\evar(102)}\app(\app(\symb(3), \symb(
5)), \symb(6)) | .Proof | 4 > .


eof
set trace on .
q


eof
rew in PRETTY : pretty(gen-proof2(
    \app(\app(\symb(1), \evar(2)), \app(\app(\symb(3), \evar(4)), \evar(2))),
    \app(\app(\symb(1), \evar(2)), \app(\app(\symb(3), \symb(5)), \symb(6)))
    )) .
rew in PRETTY : check(gen-proof2(
    \app(\app(\symb(1), \evar(2)), \app(\app(\symb(3), \evar(4)), \evar(2))),
    \app(\app(\symb(1), \evar(2)), \app(\app(\symb(3), \symb(5)), \symb(6)))
    )) .

q

red in SETUP : (\app(\symb(1), \evar(1))) ⊔ (\app(\symb(1), \evar(1))) .
red in SETUP : dec-reverse(\app(\symb(1), \evar(1)), \app(\symb(1), \evar(1))) .

*** f(a,x) , f(b,y)
red in SETUP : dec-reverse(\app(\app(\symb(2), \symb(1)), \evar(1)),
                           \app(\app(\symb(2), \symb(5)), \evar(2))) .

*** g(a,x) , f(b,y)
red in SETUP : dec-reverse(\app(\app(\symb(3), \symb(1)), \evar(1)),
                           \app(\app(\symb(2), \symb(5)), \evar(2))) .

*** f(g(a), x) , f(g(b), y)
red in SETUP : dec-reverse(\app(\app(\symb(2), \app(\symb(3), \symb(1))), \evar(1)),
                           \app(\app(\symb(2), \app(\symb(3), \symb(5))), \evar(2))) .

*** g(g(a), x) , f(g(b), y)
red in SETUP : dec-reverse(\app(\app(\symb(3), \app(\symb(3), \symb(1))), \evar(1)),
                           \app(\app(\symb(2), \app(\symb(3), \symb(5))), \evar(2))) .

q





endm

mod ANTI-UNIFICATION is
    pr SETUP .

endm


rew in ANTI-UNIFICATION : < subst-nil | \app(\symb(1), \app(\symb(2), \symb(3))) = \evar(5) @ \app(\symb(1), \app(\symb(2), \evar(4))) > .

rew in ANTI-UNIFICATION : extract-lgg(< subst-nil | \app(\symb(1), \app(\symb(2), \symb(3))) = \evar(5) @ \app(\symb(1), \app(\symb(2), \evar(4))) >) .

rew in ANTI-UNIFICATION : extract-sigma-1(< subst-nil | \app(\symb(1), \app(\symb(2), \symb(3))) = \evar(5) @ \app(\symb(1), \app(\symb(2), \evar(4))) >) .

rew in ANTI-UNIFICATION : extract-sigma-2(< subst-nil | \app(\symb(1), \app(\symb(2), \symb(3))) = \evar(5) @ \app(\symb(1), \app(\symb(2), \evar(4))) >) .




mod PROOF-GENERATION is
    inc ANTI-UNIFICATION .
    pr CHECKER .
    pr INT .


    op gen-proof1 : TermPattern TermPattern -> Proof .
    op gen-proof2 : TermPattern TermPattern -> Proof .

    --- Stage 1
    
    
endm






        op extract-lgg : AUnifProblem -> TermPattern .
    ceq extract-lgg(< PL | Eqs >) = Phi
       if subst-pair(X, Phi) := collapse(PL) .

    op extract-sigma-1 : AUnifProblem -> SubstList .
    eq extract-sigma-1(< PL | Eqs >) = extract-left(Eqs) .
    op extract-sigma-2 : AUnifProblem -> SubstList .
    eq extract-sigma-2(< PL | Eqs >) = extract-right(Eqs) .

    var E : Equation .
    vars Es : Equations .
    var Sigma : SubstPair .
    var Sigmas : SubstList .
    op extract-left : Equations -> SubstList .
    eq extract-left(.Equations) = subst-nil .
    eq extract-left((Phi = X @ Phi')) = subst-cons(subst-pair(X, Phi), subst-nil) .
    ceq extract-left(((Phi = X @ Phi') Es)) = subst-cons(subst-pair(X, Phi), Sigmas)
      if Sigmas := extract-left(Es) .
    op extract-right : Equations -> SubstList .
    eq extract-right(.Equations) = subst-nil .
    eq extract-right((Phi = X @ Phi')) = subst-cons(subst-pair(X, Phi'), subst-nil) .
    ceq extract-right(((Phi = X @ Phi') Es)) = subst-cons(subst-pair(X, Phi'), Sigmas)
      if Sigmas := extract-right(Es) .


